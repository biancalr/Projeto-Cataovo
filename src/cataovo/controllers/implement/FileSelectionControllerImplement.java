/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package cataovo.controllers.implement;

import cataovo.utils.constants.Constants;
import cataovo.controllers.FileSelectionController;
import cataovo.entities.Frame;
import cataovo.entities.Palette;
import cataovo.utils.enums.FileExtension;
import cataovo.utils.enums.ProcessingMode;
import cataovo.exceptions.DirectoryNotValidException;
import cataovo.exceptions.ImageNotValidException;
import cataovo.exceptions.ReportNotValidException;
import cataovo.externals.UI.swing.wrappers.FileChooserUI;
import cataovo.externals.UI.swing.wrappers.TabbedPane;
import cataovo.resources.MainResources;
import cataovo.resources.fileChooser.handler.FileFilterExtensions;
import cataovo.resources.fileChooser.handler.FileListHandler;
import java.awt.Component;
import java.awt.HeadlessException;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Collection;
import java.util.LinkedList;
import java.util.Queue;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Controls the interactions with the files from outside the Application.
 *
 * @author Bianca Leopoldo Ramos
 */
public class FileSelectionControllerImplement implements FileSelectionController {

    private static final Logger LOG = Logger.getLogger(FileSelectionControllerImplement.class.getName());
    private final FileChooserUI fileChooser;

    public FileSelectionControllerImplement() throws DirectoryNotValidException {
        fileChooser = MainResources.getInstance().getFileChooserUI();
    }

    /**
     * Selects an event and an action based on the action commands.
     * <p>
     * The action command <strong>Open Palette</strong> opens a Open dialog
     * selection that permits to select a folder that represents a Palette, wich
     * in essence is a folder containg images of the eggs.
     * </p>
     * <p>
     * The action command <strong>Select Destination</strong> Folder opens a
     * saving dialog selection that permits to select a folder where the
     * analisys of each processing mode saves its folder. It should be used with
     * caution because each processing mode resets the saving folder.
     * </p>
     * <p>
     * The action command <strong>Select Report</strong> opens a Open dialog
     * selection where it allows to select the report generated by Manual and
     * Automatic processing mods and use them as entry to the Evaluation mode.
     * </p>
     *
     * @param actionCommand comand that defines a dialog showing actions
     * @param parent
     * @param isADirectoryOnly <code>True</code> if the selection mode is a
     * <code>DIRECTORY_ONLY</code> or <code>False</code> if the selection mode
     * is a <code>FILES_AND_DIRECTORIES</code>
     * @return
     * @throws cataovo.exceptions.DirectoryNotValidException
     * @throws cataovo.exceptions.ImageNotValidException
     * @throws java.io.FileNotFoundException
     * @throws cataovo.exceptions.ReportNotValidException
     */
    @Override
    public boolean fileSelectionEvent(String actionCommand, Component parent, boolean isADirectoryOnly) throws DirectoryNotValidException, ImageNotValidException, FileNotFoundException, ReportNotValidException {
        if (!MainResources.getInstance().getPanelTabHelper().isIsActualTabProcessing()) {
            switch (actionCommand) {
                case Constants.ITEM_ACTION_COMMAND_OPEN_PALETTE_PT_BR -> {
                    return actionCommandOpenFolder(isADirectoryOnly, parent);
                }
                case Constants.ITEM_ACTION_COMMAND_SELECT_DESTINATION_FOLDER_PT_BR -> {
                    return actionCommandSetSavingFolder(isADirectoryOnly, parent);
                }
                case Constants.ITEM_ACTION_COMMAND_SELECT_REPORT_PT_BR -> {
                    return actionCommandSelectReport(isADirectoryOnly, parent);
                }
                default -> {
                    LOG.log(Level.WARNING, "Not implemented yet {0}", actionCommand);
                    return false;
                }
            }

        }
        return false;
    }

    /**
     * The behavior for the action ACTION_COMMAND_ABRIR_PASTA. Sets a Palette to
     * work with.
     *
     * @param isADirectoryOnly
     * @param parent
     * @return
     * @throws FileNotFoundException
     * @throws DirectoryNotValidException
     * @throws ImageNotValidException
     */
    private boolean actionCommandOpenFolder(boolean isADirectoryOnly, Component tabbedPane) throws FileNotFoundException, DirectoryNotValidException, ImageNotValidException, HeadlessException {
        FileChooserUI chooser = this.fileChooser;
        chooser.resetChoosableFileFilters();
        chooser.setFileFilter(null);
        File file = chooser.dialogs(Constants.OPEN_DIALOG, isADirectoryOnly, tabbedPane);
        TabbedPane pane = new TabbedPane(tabbedPane);
        if (file != null && file.exists()) {
            // Set the palette which represents the folder where the frames are contained

            MainResources.getInstance().setPalette(setNewPalette(file));
            MainResources.getInstance().resetSavingFolder();

            if (pane.getTabbedPane().getSelectedIndex() == 0) {
                MainResources.getInstance().getPalette().getFrames().poll();
            }
            if (pane.getTabbedPane().getSelectedIndex() != 2) {
                MainResources.getInstance().adjustPanelTab(tabbedPane, true);
            }

            MainResources.getInstance().setReports(new String[2]);
            return true;
        }
        return false;
    }

    /**
     *
     * @param isADirectoryOnly
     * @param parent
     * @return
     * @throws DirectoryNotValidException
     * @throws HeadlessException
     */
    private boolean actionCommandSelectReport(final boolean isADirectoryOnly, final Component parent) throws DirectoryNotValidException, HeadlessException, ReportNotValidException {
        FileChooserUI chooser = this.fileChooser;
        chooser.resetChoosableFileFilters();
        chooser.addChoosableFileFilter(new FileFilterExtensions(FileExtension.CSV));
        chooser.setFileFilter(new FileFilterExtensions(FileExtension.CSV));
        chooser.setExtensionType(FileExtension.CSV);
        File file = chooser.dialogs(Constants.OPEN_DIALOG, isADirectoryOnly, parent);
        if (isAValidFileReportOnPalette(file)) {
            return setReports(file);
        } else {
            LOG.log(Level.WARNING, "Couldn't pass all the validations for a csv report");
            return false;
        }

    }

    /**
     *
     * @param file
     * @param parent
     * @return
     * @throws ReportNotValidException
     * @throws DirectoryNotValidException
     */
    private boolean setReports(File file) throws ReportNotValidException, DirectoryNotValidException {
        // Fixar ordem dos relatórios: o primeiro deve ser o relatório de contagem manual
        // verificar se o primeiro relatório corresponde ao relatório da contagem manual
        // Receber os relatórios em qualquer ordem no array na posição correta
        String nameReport = "";
        int position = 0;
        if (file.getAbsolutePath().contains(ProcessingMode.MANUAL.getProcessingMode())) {
            nameReport = ProcessingMode.MANUAL.getProcessingMode();
            position = 0;
        } else if (file.getAbsolutePath().contains(ProcessingMode.AUTOMATIC.getProcessingMode())) {
            nameReport = ProcessingMode.AUTOMATIC.getProcessingMode();
            position = 1;
        } else {
            throw new ReportNotValidException("Report not properly selected");
        }
        return evaluationReportsFile(nameReport, file, position);

    }

    private boolean isAValidFileReportOnPalette(File file) throws DirectoryNotValidException {
        return file != null && file.exists() && file.isFile()
                && file.getAbsolutePath().contains(FileExtension.CSV.getExtension());
    }

    /**
     *
     * @param nameReport
     * @param file
     * @param parent
     * @return
     * @throws DirectoryNotValidException
     */
    private boolean evaluationReportsFile(String nameReport, File file, int position) throws DirectoryNotValidException {
        String msg = "Relatório para " + nameReport.toUpperCase();
        MainResources.getInstance().addReport(file.getAbsolutePath(), position);
        LOG.log(Level.INFO, "{0} foi adicionado: {1}", new Object[]{msg, file.getPath()});
        return true;
    }

    /**
     * The behavior for the action ACTION_COMMAND_SELECIONAR_PASTA_DESTINO. Sets
     * a folder where the final report will be saved.
     *
     * @param isADirectoryOnly
     * @param parent
     * @return
     * @throws DirectoryNotValidException
     */
    private boolean actionCommandSetSavingFolder(boolean isADirectoryOnly, Component parent) throws DirectoryNotValidException {
        LOG.log(Level.INFO, "Setting a new saving Folder.");
        FileChooserUI chooser = this.fileChooser;
        chooser.resetChoosableFileFilters();
        chooser.setFileFilter(null);
        File file = chooser.dialogs(Constants.OPEN_DIALOG, isADirectoryOnly, parent);
        if (file != null && file.exists()) {
            // Set the folder where the result will be saved.
            MainResources.getInstance().setSavingFolder(file);
            LOG.log(Level.INFO, "A new saving Folder {0}", file);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Set the file to a Palette. Verify if the file is a valid one.
     *
     * @param selectedFile
     * @return a new Palette to start the analisys
     * @throws DirectoryNotValidException
     */
    private Palette setNewPalette(File selectedFile) throws DirectoryNotValidException, ImageNotValidException, FileNotFoundException {
        LOG.log(Level.INFO, "Setting a new Palette...");
        Palette pal = null;
        if (selectedFile.exists()) {
            if (selectedFile.isDirectory()) {
                pal = new Palette(selectedFile);
                pal.setFrames(setPaletteFrames(selectedFile.listFiles()));
                MainResources.getInstance().setCurrentFrame(pal.getFrames().peek());
                MainResources.getInstance().getPaletteToSave().setDirectory(pal.getDirectory());
            } else {
                throw new DirectoryNotValidException("The selected file is not a directory. Please, choose a directory.");
            }
            LOG.info(pal.toString());
            LOG.log(Level.INFO, "A new Palette was created with the amount of frames: {0}", pal.getFrames().size());
        } else {
            LOG.log(Level.WARNING, "The selected file doesn't exist. Please, select an existing file.");
            throw new FileNotFoundException("The selected file doesn't exist. Please, select an existing file.");
        }
        return pal;
    }

    /**
     * Set the Frames in a Palette. When a Palette is chosen, their frames must
     * be presented as a Queue. If the chosen file is a directory, there might
     * be nested directories. So these images must be normalized to a sigle
     * queue.
     *
     *
     * @param listFiles
     * @return
     */
    private Queue<Frame> setPaletteFrames(File[] listFiles) throws DirectoryNotValidException, ImageNotValidException {
        Queue<Frame> frames = new LinkedList<>();
        Collection<File> colection = new FileListHandler<File>().normalizeFilesOnAList(listFiles, FileExtension.PNG);
        Frame frame;
        for (File file1 : colection) {
            frame = new Frame(file1.getPath());
            frame.setName(Constants.FRAME_ID_TAG + frame.getName());
            frames.add(frame);
            LOG.log(Level.INFO, "Adding following frame: {0}", frame.getName());
        }
        return frames;
    }
}
